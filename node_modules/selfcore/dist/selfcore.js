var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
import axios from "axios";
import WebSocket from "ws";
import EventEmitter from "events";
const eventEmitter = new EventEmitter();
class Selfcore {
  constructor(token) {
    this.token = token;
    this.headers = {
      authorization: this.token,
      accept: "*/*",
      "accept-language": "en-US",
      referer: "https://discord.com/channels/@me",
      "sec-fetch-dest": "empty",
      "sec-fetch-mode": "cors",
      "sec-fetch-site": "same-origin",
      "user-agent": `Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_0) AppleWebKit/537.36 (KHTML, like Gecko) discord/0.0.263 Chrome/83.0.4103.122 Electron/9.3.5 Safari/537.36`,
      "x-debug-options": "bugReporterEnabled",
      "x-super-properties":
        "eyJvcyI6Ik1hYyBPUyBYIiwiYnJvd3NlciI6IkRpc2NvcmQgQ2xpZW50IiwicmVsZWFzZV9jaGFubmVsIjoic3RhYmxlIiwiY2xpZW50X3ZlcnNpb24iOiIwLjAuMjYzIiwib3NfdmVyc2lvbiI6IjIwLjUuMCIsIm9zX2FyY2giOiJ4NjQiLCJzeXN0ZW1fbG9jYWxlIjoiZW4tVVMiLCJjbGllbnRfYnVpbGRfbnVtYmVyIjo5MzQ1MiwiY2xpZW50X2V2ZW50X3NvdXJjZSI6bnVsbH0=",
    };
  }
  sendMessage(channelId, content) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let res = yield axios.post(
          `https://discord.com/api/v9/channels/${channelId}/messages`,
          {
            content,
          },
          { headers: this.headers }
        );
        return res.data;
      } catch (err) {
        return { error: err };
      }
    });
  }
  deleteMessage(channelId, messageId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let res = yield axios.delete(
          `https://discord.com/api/v9/channels/${channelId}/messages/${messageId}`,
          { headers: this.headers }
        );
      } catch (err) {
        return { error: err.response.data.message };
      }
    });
  }
  joinGuild(invite) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log(this.headers);
        let res = yield axios.post(
          `https://discord.com/api/v9/invites/${invite}`,
          undefined,
          { headers: this.headers }
        );
      } catch (err) {
        console.log(err);
        return { error: err };
      }
    });
  }
  sendWebhook(url, message) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (typeof message === "object") {
          console.log(message);
          let res = yield axios.post(url, message);
          return res.data;
        } else {
          let res = yield axios.post(url, { content: message });
          return res.data;
        }
      } catch (err) {
        return { error: err };
      }
    });
  }
  getProfile() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let res = yield axios.get(
          "https://discord.com/api/v9/users/816004387574251621/profile?with_mutual_guilds=false",
          { headers: this.headers }
        );
        return res.data;
      } catch (err) {
        return { error: err };
      }
    });
  }
}
Selfcore.Gateway = class extends EventEmitter {
  constructor(token) {
    super();
    this.heartbeat = (ms) => {
      return setInterval(() => {
        this.ws.send(JSON.stringify({ op: 1, d: null }));
      }, ms);
    };
    this.token = token;
    this.ws = new WebSocket("wss://gateway.discord.gg/?v=6&encoding=json");
    this.payload = {
      op: 2,
      d: {
        token: this.token,
        properties: {
          $os: "linux",
          $browser: "chrome",
          $device: "chrome",
        },
      },
    };
    this.ws.on("open", () => {
      this.ws.send(JSON.stringify(this.payload));
    });
    this.ws.on("message", (data) => {
      let payload = JSON.parse(data);
      const { t, event, op, d } = payload;
      switch (op) {
        case 10:
          const { heartbeat_interval } = d;
          this.interval = this.heartbeat(heartbeat_interval);
          this.emit("ready");
          break;
      }
      switch (t) {
        case "MESSAGE_CREATE":
          // console.log(d);
          this.emit("message", d);
      }
    });
  }
};
export default Selfcore;
//# sourceMappingURL=selfcore.js.map
