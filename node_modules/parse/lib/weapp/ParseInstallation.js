"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _CoreManager = _interopRequireDefault(require("./CoreManager"));
var _ParseObject2 = _interopRequireDefault(require("./ParseObject"));
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function () {
    var Super = (0, _getPrototypeOf2.default)(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2.default)(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !_Reflect$construct) return false;
  if (_Reflect$construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
var DEVICE_TYPES /*: DeviceInterface*/ = {
  IOS: 'ios',
  MACOS: 'macos',
  TVOS: 'tvos',
  FCM: 'fcm',
  ANDROID: 'android',
  WEB: 'web'
};

/**
 * Parse.Installation is a local representation of installation data that can be saved and retrieved from the Parse cloud.
 * This class is a subclass of a Parse.Object, and retains the same functionality of a Parse.Object, but also extends it with installation-specific features.
 *
 * <p>A valid Parse.Installation can only be instantiated via <code>Parse.Installation.currentInstallation()</code>
 *
 * Parse.Installation objects which have a valid <code>deviceToken</code> and are saved to the Parse cloud can be used to target push notifications.
 * </p>
 *
 * @alias Parse.Installation
 */
var ParseInstallation = /*#__PURE__*/function (_ParseObject) {
  (0, _inherits2.default)(ParseInstallation, _ParseObject);
  var _super = _createSuper(ParseInstallation);
  /**
   * @param {object} attributes The initial set of data to store in the object.
   */
  function ParseInstallation(attributes /*:: ?: AttributeMap*/) {
    var _this;
    (0, _classCallCheck2.default)(this, ParseInstallation);
    _this = _super.call(this, '_Installation');
    if (attributes && (0, _typeof2.default)(attributes) === 'object') {
      if (!_this.set(attributes)) {
        throw new Error("Can't create an invalid Installation");
      }
    }
    return _this;
  }

  /**
   * A unique identifier for this installation’s client application. In iOS, this is the Bundle Identifier.
   *
   * @property {string} appIdentifier
   * @static
   */
  (0, _createClass2.default)(ParseInstallation, [{
    key: "appIdentifier",
    get: function () {
      return this.get('appIdentifier');
    }

    /**
     * The version string of the client application to which this installation belongs.
     *
     * @property {string} appVersion
     * @static
     */
  }, {
    key: "appVersion",
    get: function () {
      return this.get('appVersion');
    }

    /**
     * The display name of the client application to which this installation belongs.
     *
     * @property {string} appName
     * @static
     */
  }, {
    key: "appName",
    get: function () {
      return this.get('appName');
    }

    /**
     * The current value of the icon badge for iOS apps.
     * Changes to this value on the server will be used
     * for future badge-increment push notifications.
     *
     * @property {number} badge
     * @static
     */
  }, {
    key: "badge",
    get: function () {
      return this.get('badge');
    }

    /**
     * An array of the channels to which a device is currently subscribed.
     *
     * @property {string[]} channels
     * @static
     */
  }, {
    key: "channels",
    get: function () {
      return this.get('channels');
    }

    /**
     * Token used to deliver push notifications to the device.
     *
     * @property {string} deviceToken
     * @static
     */
  }, {
    key: "deviceToken",
    get: function () {
      return this.get('deviceToken');
    }

    /**
     * The type of device, “ios”, “android”, “web”, etc.
     *
     * @property {string} deviceType
     * @static
     */
  }, {
    key: "deviceType",
    get: function () {
      return this.get('deviceType');
    }

    /**
     * Gets the GCM sender identifier for this installation
     *
     * @property {string} GCMSenderId
     * @static
     */
  }, {
    key: "GCMSenderId",
    get: function () {
      return this.get('GCMSenderId');
    }

    /**
     * Universally Unique Identifier (UUID) for the device used by Parse. It must be unique across all of an app’s installations.
     *
     * @property {string} installationId
     * @static
     */
  }, {
    key: "installationId",
    get: function () {
      return this.get('installationId');
    }

    /**
     * Gets the local identifier for this installation
     *
     * @property {string} localeIdentifier
     * @static
     */
  }, {
    key: "localeIdentifier",
    get: function () {
      return this.get('localeIdentifier');
    }

    /**
     * Gets the parse server version for this installation
     *
     * @property {string} parseVersion
     * @static
     */
  }, {
    key: "parseVersion",
    get: function () {
      return this.get('parseVersion');
    }

    /**
     * This field is reserved for directing Parse to the push delivery network to be used.
     *
     * @property {string} pushType
     * @static
     */
  }, {
    key: "pushType",
    get: function () {
      return this.get('pushType');
    }

    /**
     * Gets the time zone for this installation
     *
     * @property {string} timeZone
     * @static
     */
  }, {
    key: "timeZone",
    get: function () {
      return this.get('timeZone');
    }

    /**
     * Returns the device types for used for Push Notifications.
     *
     * <pre>
     * Parse.Installation.DEVICE_TYPES.IOS
     * Parse.Installation.DEVICE_TYPES.MACOS
     * Parse.Installation.DEVICE_TYPES.TVOS
     * Parse.Installation.DEVICE_TYPES.FCM
     * Parse.Installation.DEVICE_TYPES.ANDROID
     * Parse.Installation.DEVICE_TYPES.WEB
     * </pre
     *
     * @property {object} DEVICE_TYPES
     * @static
     */
  }, {
    key: "save",
    value:
    /**
     * Wrap the default save behavior with functionality to save to local storage.
     *
     * @param {...any} args
     * @returns {Promise}
     */
    function () {
      var _save = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _len,
          args,
          _key,
          _args = arguments;
        return _regenerator.default.wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = _args[_key];
              }
              _context.next = 3;
              return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseInstallation.prototype), "save", this).apply(this, args);
            case 3:
              _context.next = 5;
              return _CoreManager.default.getInstallationController().updateInstallationOnDisk(this);
            case 5:
              return _context.abrupt("return", this);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function save() {
        return _save.apply(this, arguments);
      }
      return save;
    }()
    /**
     * Get the current Parse.Installation from disk. If doesn't exists, create an new installation.
     *
     * <pre>
     * const installation = await Parse.Installation.currentInstallation();
     * installation.set('deviceToken', '123');
     * await installation.save();
     * </pre>
     *
     * @returns {Promise} A promise that resolves to the local installation object.
     */
  }], [{
    key: "DEVICE_TYPES",
    get: function () /*: DeviceInterface*/{
      return DEVICE_TYPES;
    }
  }, {
    key: "currentInstallation",
    value: function () /*: Promise<ParseInstallation>*/{
      return _CoreManager.default.getInstallationController().currentInstallation();
    }
  }]);
  return ParseInstallation;
}(_ParseObject2.default);
_ParseObject2.default.registerSubclass('_Installation', ParseInstallation);
module.exports = ParseInstallation;
var _default = ParseInstallation;
exports.default = _default;